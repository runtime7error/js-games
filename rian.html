<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Limpa o Barro do Rian</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --card:#111827ee; /* gray-900 */
      --accent:#22c55e; /* green-500 */
      --accent2:#eab308; /* amber-500 */
      --danger:#ef4444; /* red-500 */
      --text:#e5e7eb; /* gray-200 */
      --muted:#94a3b8; /* slate-400 */
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial; color:var(--text); background:
        radial-gradient(80vmax 80vmax at 10% 10%, #1f2937 0, transparent 60%),
        radial-gradient(80vmax 80vmax at 90% 10%, #1e3a8a 0, transparent 60%),
        var(--bg);
      min-height:100svh; display:grid; place-items:center; padding:16px;
    }
    .wrap{width:min(1050px,100%);}
    .card{background:linear-gradient(180deg,#0b1020aa,#0b102066); border:1px solid #33415566; border-radius:18px; padding:16px; box-shadow:0 10px 30px #0008}
    header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
    h1{font-size:clamp(20px,3.2vw,34px); margin:0; letter-spacing:.3px}
    .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .pill{display:inline-flex; align-items:center; gap:6px; border:1px solid #334155; background:#0b1220; padding:8px 12px; border-radius:999px; font-weight:600}
    .pill .dot{width:10px;height:10px;border-radius:50%; background:var(--accent)}
    .btn{border:1px solid #334155; background:#0b1220; color:var(--text); padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer; transition:.2s transform,.2s background,.2s border}
    .btn:hover{transform:translateY(-1px); border-color:#475569}
    .btn.primary{background:linear-gradient(90deg,#16a34a,#22c55e); color:#06110a}
    .btn.danger{background:linear-gradient(90deg,#ef4444,#f97316); color:#220804}
    .meta{display:flex; gap:10px; flex-wrap:wrap}
    .meta .tag{background:#0b1220; border:1px solid #334155; padding:8px 10px; border-radius:10px; font-size:14px}
    .bar{height:12px; background:#0b1220; border:1px solid #334155; border-radius:999px; overflow:hidden; position:relative}
    .bar > .fill{height:100%; width:0%; background:linear-gradient(90deg,#22c55e,#84cc16); box-shadow:inset 0 0 10px #0008}
    .grid{display:grid; grid-template-columns:320px 1fr; gap:16px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}

    /* Game area */
    .stage{position:relative; aspect-ratio: 16/10; width:100%; background:
        linear-gradient(180deg,#dbeafe 0,#bfdbfe 100%); border-radius:18px; overflow:hidden; border:1px solid #93c5fd; box-shadow:inset 0 -60px 120px #0000001a}
    .bed{
      position:absolute; inset:0; background:
        radial-gradient(120% 70% at 50% -20%, #ffffff 0, #f1f5f9 45%, #e2e8f0 60%, #cbd5e1 75%),
        repeating-linear-gradient(90deg,#f8fafc 0 8px,#eef2ff 8px 16px);
      filter: drop-shadow(0 20px 40px #0004);
    }
    canvas{position:absolute; inset:0; width:100%; height:100%; image-rendering:pixelated}
    .hud{position:absolute; left:12px; top:12px; display:flex; gap:8px; flex-wrap:wrap}
    .hud .chip{background:#0b1220cc; border:1px solid #334155; padding:6px 10px; border-radius:10px; font-weight:700}
    .toast{position:absolute; inset:auto 0 12px 0; margin:auto; width:max(260px,40%); text-align:center; background:#0b1220dd; border:1px solid #334155; padding:12px 16px; border-radius:12px; font-weight:700; display:none}
    .toast.show{display:block}

    .panel{background:#0b1220ee; position:absolute; inset:0; display:grid; place-items:center}
    .panel .inner{width:min(560px,92%); text-align:center; background:#0a0f1c; border:1px solid #334155; border-radius:16px; padding:20px; box-shadow:0 20px 60px #000a}
    .title{font-size:28px; margin:0 0 6px}
    .subtitle{margin:0 0 14px; color:var(--muted)}
    .opts{display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:12px 0}
    .opt{border:1px solid #334155; background:#0b1220; padding:10px 14px; border-radius:12px; cursor:pointer}
    .opt[data-active="true"]{outline:2px solid #22c55e; outline-offset:2px}

    /* Cursor brush */
    .cursor{position:absolute; width:60px; height:60px; border-radius:50%; border:2px dashed #10b981; pointer-events:none; mix-blend-mode:plus-lighter; opacity:.8; transform:translate(-50%,-50%) scale(1); transition:.06s transform}

    /* Confetti */
    .confetti{position:absolute; inset:0; pointer-events:none; overflow:hidden}
    .confetti i{position:absolute; width:8px; height:14px; background:linear-gradient(180deg,#fff,#ddd); transform:translateY(-20px) rotate(0deg); animation: drop 2.4s linear forwards}
    @keyframes drop{
      100%{transform:translateY(120%) rotate(680deg)}
    }

    /* Debug info */
    .debug{position:absolute; top:60px; left:12px; background:#0b1220cc; border:1px solid #334155; padding:6px 10px; border-radius:10px; font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1>üßΩ Limpa o Barro do Rian</h1>
        <div class="controls">
          <button class="btn" id="btnReset" title="Recome√ßar (R)">‚Ü∫ Recome√ßar</button>
          <button class="btn primary" id="btnPower" title="Turbo por 3s (Espa√ßo)">‚ö° Turbo</button>
          <button class="btn danger" id="btnShaker" title="Sacode a cama (S)">üõèÔ∏è Sacudir</button>
        </div>
      </header>
      <div class="meta" style="margin-top:10px">
        <div class="tag">‚è±Ô∏è Tempo: <b id="uiTimer">60.0</b>s</div>
        <div class="tag">üßº Limpeza: <b id="uiClean">0%</b></div>
        <div class="tag">üò¨ N√≠vel Rian: <b id="uiLevel">Suave</b></div>
        <div class="tag" title="Velocidade da esponja">üßΩ Raio: <b id="uiBrush">28</b>px</div>
      </div>
      <div class="bar" style="margin:10px 0 14px">
        <div class="fill" id="progress"></div>
      </div>
      <div class="grid">
        <div class="card" style="min-height:140px">
          <h3 style="margin:0 0 6px">Como jogar</h3>
          <ul style="margin:0 0 12px 18px; color:var(--muted)">
            <li>Segure e arraste a esponja sobre as manchas para limpar.</li>
            <li>Complete <b>100% de limpeza</b> antes do tempo acabar.</li>
            <li><b>Turbo</b> (bot√£o ou tecla <kbd>Espa√ßo</kbd>) aumenta o raio por 3s.</li>
            <li><b>Sacudir</b> (bot√£o ou tecla <kbd>S</kbd>) desloca as manchas üëÄ.</li>
            <li>No celular: toque e arraste com o dedo.</li>
          </ul>
          <div style="display:flex; gap:8px; flex-wrap:wrap">
            <span class="pill" title="Detec√ß√£o precisa melhorada"><span class="dot"></span> Sistema de Limpeza Aprimorado</span>
            <span class="pill" title="Compat√≠vel com toque e mouse"><span class="dot" style="background:var(--accent2)"></span> Suporte Mobile</span>
          </div>
        </div>
        <div class="stage card" id="stage">
          <div class="bed"></div>
          <canvas id="game"></canvas>
          <div class="hud">
            <div class="chip">‚è±Ô∏è <span id="hudTime">60.0</span>s</div>
            <div class="chip">üßº <span id="hudClean">0</span>%</div>
          </div>
          <div class="debug" id="debug" style="display:none">
            Pixels sujos: <span id="debugDirty">0</span> / <span id="debugTotal">0</span>
          </div>
          <div class="toast" id="toast">Segure e arraste para limpar o caos do Rian!</div>
          <div class="confetti" id="confetti"></div>
          <div class="cursor" id="cursor" hidden></div>

          <div class="panel" id="panel">
            <div class="inner">
              <p class="title">Rian passou por aqui‚Ä¶ üòÖ</p>
              <p class="subtitle">Sua miss√£o: deixar a cama impec√°vel antes que algu√©m veja.</p>
              <div>
                <div class="opts">
                  <button class="opt" data-diff="easy" data-active="true">Suave</button>
                  <button class="opt" data-diff="normal">Tenso</button>
                  <button class="opt" data-diff="hard">Ca√≥tico</button>
                </div>
                <button class="btn primary" id="btnPlay">‚ñ∂Ô∏è Jogar</button>
              </div>
              <p class="subtitle" style="margin-top:12px">Dica: use o Turbo quando o tempo apertar.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    const $ = sel => document.querySelector(sel);
    const stage = $('#stage');
    const canvas = $('#game');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const progressEl = $('#progress');
    const uiTimer = $('#uiTimer'), hudTime = $('#hudTime');
    const uiClean = $('#uiClean'), hudClean = $('#hudClean');
    const uiLevel = $('#uiLevel');
    const uiBrush = $('#uiBrush');
    const btnPlay = $('#btnPlay');
    const btnReset = $('#btnReset');
    const btnPower = $('#btnPower');
    const btnShaker = $('#btnShaker');
    const toast = $('#toast');
    const panel = $('#panel');
    const confettiBox = $('#confetti');
    const cursor = $('#cursor');
    const debug = $('#debug');

    let W=0,H=0, DPR = Math.min(2, window.devicePixelRatio||1);
    let playing=false, over=false;

    // Dirt tracking - canvas separado para m√°scara de sujeira
    let dirtCanvas, dirtCtx;
    let initialDirtPixels = 0;

    // Game state
    let timerMax=60, timer=60;
    let brushBase=28, brush=28;
    let turbo=false, turboUntil=0;
    let cleanPercent = 0;
    let lastSampleT = 0;

    // Pointer
    let px=0, py=0, down=false;

    // Difficulty presets
    const DIFF = {
      easy:   {spots: 18, spread: 0.9, timer: 60, brush: 30},
      normal: {spots: 26, spread: 1.1, timer: 55, brush: 26},
      hard:   {spots: 34, spread: 1.3, timer: 50, brush: 22},
    };
    let currentDiff = 'easy';

    // Initialize dirt mask canvas
    function initDirtMask(){
      if(!dirtCanvas){
        dirtCanvas = document.createElement('canvas');
        dirtCtx = dirtCanvas.getContext('2d', { willReadFrequently: true });
      }
      dirtCanvas.width = W;
      dirtCanvas.height = H;
      dirtCtx.clearRect(0,0,W,H);
    }

    // Responsive canvas sizing
    function fit(){
      const r = stage.getBoundingClientRect();
      W = Math.floor(r.width * DPR);
      H = Math.floor(r.height * DPR);
      canvas.width = W; canvas.height = H;
      canvas.style.width = r.width+'px';
      canvas.style.height = r.height+'px';
      
      // Reinitialize dirt mask with new size
      initDirtMask();
      
      drawBackground();
      if(!playing) drawDirtPreview();
    }
    window.addEventListener('resize', fit, {passive:true});

    function drawBackground(){
      // subtle bed shading overlay
      ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'rgba(0,0,0,0.06)');
      g.addColorStop(1,'rgba(0,0,0,0.12)');
      ctx.fillStyle = g; 
      ctx.fillRect(0,0,W,H);
    }

    function rand(a,b){return Math.random()*(b-a)+a}

    function splatDirt(targetCtx, seed){
      // Draw multiple organic blobs to specified context
      const spots = seed.spots;
      targetCtx.save();
      targetCtx.globalCompositeOperation='source-over';
      
      for(let i=0;i<spots;i++){
        const x = rand(.1,.9) * W;
        const y = rand(.15,.85) * H;
        const r = rand(18, 70) * DPR * seed.spread;
        const rot = rand(0,Math.PI*2);
        const layers = Math.floor(rand(2,5));
        
        for(let l=0;l<layers;l++){
          const rr = r * (1 - l*0.18) * rand(.9,1.1);
          const ox = rand(-r*0.2,r*0.2), oy = rand(-r*0.2,r*0.2);
          targetCtx.translate(x+ox, y+oy); 
          targetCtx.rotate(rot + l*0.2);
          
          const grad = targetCtx.createRadialGradient(0,0, rr*0.2, 0,0, rr);
          grad.addColorStop(0, 'rgba(84,54,13,0.9)');
          grad.addColorStop(0.6, 'rgba(64,40,10,0.85)');
          grad.addColorStop(1, 'rgba(40,24,6,0.8)');
          targetCtx.fillStyle = grad;
          
          blobPath(targetCtx, rr);
          targetCtx.fill();
          targetCtx.setTransform(1,0,0,1,0,0);
        }
        
        // splashes
        const sCount = Math.floor(rand(6,14));
        for(let s=0;s<sCount;s++){
          const ang = rand(0,Math.PI*2); 
          const dist = rand(r*0.3,r*1.1);
          const sx = x + Math.cos(ang)*dist, sy = y + Math.sin(ang)*dist;
          const sr = rand(4,10) * DPR;
          targetCtx.fillStyle = 'rgba(74,44,11,0.8)';
          
          targetCtx.save();
          targetCtx.translate(sx,sy);
          blobPath(targetCtx, sr);
          targetCtx.fill();
          targetCtx.restore();
        }
      }
      targetCtx.restore();
    }

    function blobPath(targetCtx, r){
      targetCtx.beginPath();
      const n = 12;
      for(let i=0;i<n;i++){
        const ang = (i/n)*Math.PI*2;
        const rr = r * (0.75 + Math.random()*0.35);
        const x = Math.cos(ang)*rr, y = Math.sin(ang)*rr;
        if(i===0) targetCtx.moveTo(x,y); 
        else targetCtx.lineTo(x,y);
      }
      targetCtx.closePath();
    }

    function drawDirtPreview(){
      drawBackground();
      const seed = DIFF[currentDiff];
      splatDirt(ctx, seed);
    }

    function countDirtyPixels(targetCtx){
      const img = targetCtx.getImageData(0,0,W,H).data;
      let count = 0;
      
      // Count pixels with alpha > 0 (non-transparent)
      for(let i = 0; i < img.length; i += 4){
        const a = img[i + 3]; // alpha channel
        if(a > 0) count++;
      }
      return count;
    }

    function start(){
      // Initialize dirt mask
      initDirtMask();
      const seed = DIFF[currentDiff];
      
      // Generate dirt pattern in mask canvas
      splatDirt(dirtCtx, seed);
      initialDirtPixels = countDirtyPixels(dirtCtx);
      
      // Set up game state
      timerMax = seed.timer; timer = timerMax;
      brushBase = seed.brush; brush = brushBase;
      uiBrush.textContent = brushBase;
      uiLevel.textContent = currentDiff==='easy'?'Suave':currentDiff==='normal'?'Tenso':'Ca√≥tico';
      over=false; playing=true; cleanPercent=0; lastSampleT=0;
      
      // Draw visual representation
      drawBackground();
      splatDirt(ctx, seed);
      
      updateUI();
      panel.style.display='none';
      toast.classList.add('show');
      cursor.hidden=false;
      
      // Enable debug info
      debug.style.display = 'block';
      updateDebugInfo();
      
      loop(performance.now());
      popText('Valendo!');
    }

    function getCleanPercent(){
      // Verifica se o jogo foi inicializado
      if(initialDirtPixels === 0) return 100;
      
      const currentDirtyPixels = countDirtyPixels(dirtCtx);
      const cleanedPixels = Math.max(0, initialDirtPixels - currentDirtyPixels);
      const pct = Math.round((cleanedPixels / initialDirtPixels) * 100);
      
      return Math.min(100, Math.max(0, pct));
    }

    function updateDebugInfo(){
      const currentDirty = countDirtyPixels(dirtCtx);
      $('#debugDirty').textContent = currentDirty;
      $('#debugTotal').textContent = initialDirtPixels;
    }

    function cleanAtPosition(x, y, radius){
      // Clean both visual canvas and dirt mask
      
      // Clean visual canvas
      ctx.save();
      ctx.globalCompositeOperation='destination-out';
      ctx.beginPath();
      ctx.arc(x*DPR, y*DPR, radius*DPR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      
      // Clean dirt mask (this is what actually counts)
      dirtCtx.save();
      dirtCtx.globalCompositeOperation='destination-out';
      dirtCtx.beginPath();
      dirtCtx.arc(x*DPR, y*DPR, radius*DPR, 0, Math.PI*2);
      dirtCtx.fill();
      dirtCtx.restore();
    }

    function loop(t){
      if(!playing) return;
      const dt = 16; // fixed timestep approximation

      if(down){
        cleanAtPosition(px, py, brush);
      }

      // Timer
      if(!over){
        timer -= dt/1000;
        if(timer <= 0){ timer=0; gameOver(false); }
      }

      // Periodic sampling (10x/s for more responsive feedback)
      if(t - lastSampleT > 100){
        cleanPercent = getCleanPercent();
        if(cleanPercent >= 100){ gameOver(true); }
        lastSampleT = t;
        updateUI();
        updateDebugInfo();
      }

      // Turbo decay
      if(turbo && performance.now() > turboUntil){
        turbo=false; 
        brush = brushBase; 
        cursor.style.transform = `translate(-50%,-50%) scale(1)`;
        uiBrush.textContent = brushBase;
      }

      requestAnimationFrame(loop);
    }

    function updateUI(){
      const pct = cleanPercent;
      uiClean.textContent = pct + '%';
      hudClean.textContent = pct;
      progressEl.style.width = pct + '%';
      const tm = Math.max(0, timer).toFixed(1);
      uiTimer.textContent = tm; 
      hudTime.textContent = tm;
    }

    function gameOver(win){
      over=true; playing=false;
      cursor.hidden=true;
      toast.classList.remove('show');
      debug.style.display = 'none';
      panel.style.display='grid';
      btnPlay.textContent = win ? 'üéâ Jogar de novo' : '‚Ü∫ Tentar de novo';
      if(win){ 
        confetti(); 
        popText('Cama impec√°vel! üßº'); 
      } else { 
        popText('Acabou o tempo! üòµ'); 
      }
    }

    function confetti(){
      confettiBox.innerHTML='';
      const n = 120;
      for(let i=0;i<n;i++){
        const p = document.createElement('i');
        p.style.left = Math.random()*100+'%';
        p.style.top = (-20 - Math.random()*60)+'px';
        p.style.background = `hsl(${Math.random()*360},90%,60%)`;
        p.style.animationDelay = (Math.random()*0.7)+'s';
        p.style.opacity = String(0.6+Math.random()*0.4);
        p.style.transform = `translateY(-40px) rotate(${Math.random()*180}deg)`;
        confettiBox.appendChild(p);
      }
      setTimeout(()=> confettiBox.innerHTML='', 3000);
    }

    function popText(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(()=>toast.classList.remove('show'), 1500);
    }

    function activateTurbo(){
      if(over || !playing) return;
      turbo=true; 
      turboUntil = performance.now() + 3000; // 3s
      brush = Math.round(brushBase * 1.9);
      cursor.style.transform = `translate(-50%,-50%) scale(1.2)`;
      uiBrush.textContent = brush;
      popText('‚ö° TURBO!');
    }

    function shakeBed(){
      if(over || !playing) return;
      
      // Get current state of both canvases
      const visualImg = ctx.getImageData(0,0,W,H);
      const maskImg = dirtCtx.getImageData(0,0,W,H);
      
      const dx = Math.round(rand(-8,8));
      const dy = Math.round(rand(-8,8));
      
      // Clear and redraw both with offset
      ctx.clearRect(0,0,W,H);
      dirtCtx.clearRect(0,0,W,H);
      
      drawBackground(); // Redraw background first
      
      ctx.putImageData(visualImg, dx, dy);
      dirtCtx.putImageData(maskImg, dx, dy);
      
      // Clean edges that are now empty (for dirt mask only)
      dirtCtx.save();
      dirtCtx.globalCompositeOperation='destination-out';
      dirtCtx.fillStyle='rgba(0,0,0,1)';
      if(dx !== 0){
        dirtCtx.fillRect(dx > 0 ? 0 : W+dx, 0, Math.abs(dx), H);
      }
      if(dy !== 0){
        dirtCtx.fillRect(0, dy > 0 ? 0 : H+dy, W, Math.abs(dy));
      }
      dirtCtx.restore();
      
      popText('üõèÔ∏è Sacudiu a cama!');
    }

    // Pointer handling
    function setPointer(e){
      const rect = canvas.getBoundingClientRect();
      if(e.touches && e.touches[0]){
        px = (e.touches[0].clientX - rect.left);
        py = (e.touches[0].clientY - rect.top);
      }else{
        px = (e.clientX - rect.left);
        py = (e.clientY - rect.top);
      }
      cursor.style.left = px+'px';
      cursor.style.top = py+'px';
    }

    stage.addEventListener('pointerdown', e=>{ 
      if(!playing||over) return; 
      down=true; setPointer(e); 
      e.preventDefault(); 
    }, {passive:false});
    
    window.addEventListener('pointermove', e=>{ setPointer(e); }, {passive:true});
    window.addEventListener('pointerup', ()=>{ down=false; }, {passive:true});
    
    stage.addEventListener('touchstart', e=>{ 
      if(!playing||over) return; 
      down=true; setPointer(e); 
    }, {passive:false});
    
    stage.addEventListener('touchmove', e=>{ setPointer(e); }, {passive:false});
    stage.addEventListener('touchend', ()=>{ down=false; }, {passive:true});

    // Buttons & keyboard
    btnPlay.addEventListener('click', start);
    btnReset.addEventListener('click', ()=>{ 
      playing=false; over=false; 
      panel.style.display='grid'; 
      debug.style.display='none';
      drawDirtPreview(); 
      cleanPercent=0; 
      updateUI(); 
    });
    btnPower.addEventListener('click', activateTurbo);
    btnShaker.addEventListener('click', shakeBed);

    document.addEventListener('keydown', e=>{
      if(e.code==='Space'){ e.preventDefault(); activateTurbo(); }
      if(e.key.toLowerCase()==='s'){ shakeBed(); }
      if(e.key.toLowerCase()==='r'){ btnReset.click(); }
    });

    // Difficulty selection
    document.querySelectorAll('.opt').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.opt').forEach(b=>b.dataset.active='false');
        btn.dataset.active='true';
        currentDiff = btn.dataset.diff;
        drawDirtPreview();
      });
    });

    // Init
    fit();
    drawDirtPreview();
  })();
  </script>
</body>
</html>